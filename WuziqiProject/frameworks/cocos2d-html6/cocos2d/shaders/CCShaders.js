cc.SHADER_POSITION_UCOLOR_FRAG = "precision lowp float;\n" + "varying vec4 v_fragmentColor;\n" + "void main()                              \n" + "{ \n" + "    gl_FragColor = v_fragmentColor;      \n" + "}\n";
cc.SHADER_POSITION_UCOLOR_VERT = "attribute vec4 a_position;\n" + "uniform    vec4 u_color;\n" + "uniform float u_pointSize;\n" + "varying lowp vec4 v_fragmentColor; \n" + "void main(void)   \n" + "{\n" + "    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n" + "    gl_PointSize = u_pointSize;          \n" + "    v_fragmentColor = u_color;           \n" + "}";
cc.SHADER_POSITION_COLOR_FRAG = "precision lowp float; \n" + "varying vec4 v_fragmentColor; \n" + "void main() \n" + "{ \n" + "     gl_FragColor = v_fragmentColor; \n" + "} ";
cc.SHADER_POSITION_COLOR_VERT = "attribute vec4 a_position;\n" + "attribute vec4 a_color;\n" + "varying lowp vec4 v_fragmentColor;\n" + "void main()\n" + "{\n" + "    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n" + "    v_fragmentColor = a_color;             \n" + "}";
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG = "// #extension GL_OES_standard_derivatives : enable\n" + "varying mediump vec4 v_color;\n" + "varying mediump vec2 v_texcoord;\n" + "void main()\t\n" + "{ \n" + "// #if defined GL_OES_standard_derivatives\t\n" + "// gl_FragColor = v_color*smoothstep(0.0, length(fwidth(v_texcoord)), 1.0 - length(v_texcoord)); \n" + "// #else\t\n" + "gl_FragColor = v_color * step(0.0, 1.0 - length(v_texcoord)); \n" + "// #endif \n" + "}";
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT = "attribute mediump vec4 a_position; \n" + "attribute mediump vec2 a_texcoord; \n" + "attribute mediump vec4 a_color;\t\n" + "varying mediump vec4 v_color; \n" + "varying mediump vec2 v_texcoord;\t\n" + "void main() \n" + "{ \n" + "     v_color = a_color;//vec4(a_color.rgb * a_color.a, a_color.a); \n" + "     v_texcoord = a_texcoord; \n" + "    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n" + "}";
cc.SHADER_POSITION_TEXTURE_FRAG = "precision lowp float;   \n" + "varying vec2 v_texCoord;  \n" + "void main() \n" + "{  \n" + "    gl_FragColor =  texture2D(CC_Texture0, v_texCoord);   \n" + "}";
cc.SHADER_POSITION_TEXTURE_VERT = "attribute vec4 a_position; \n" + "attribute vec2 a_texCoord; \n" + "varying mediump vec2 v_texCoord; \n" + "void main() \n" + "{ \n" + "    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n" + "    v_texCoord = a_texCoord;               \n" + "}";
cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG = "precision lowp float;  \n" + "uniform vec4 u_color; \n" + "varying vec2 v_texCoord; \n" + "void main() \n" + "{  \n" + "    gl_FragColor =  texture2D(CC_Texture0, v_texCoord) * u_color;    \n" + "}";
cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT = "attribute vec4 a_position;\n" + "attribute vec2 a_texCoord; \n" + "varying mediump vec2 v_texCoord; \n" + "void main() \n" + "{ \n" + "    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n" + "    v_texCoord = a_texCoord;                 \n" + "}";
cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG = "precision lowp float;  \n" + "varying vec4 v_fragmentColor; \n" + "varying vec2 v_texCoord; \n" + "void main() \n" + "{ \n" + "    gl_FragColor = vec4( v_fragmentColor.rgb,         \n" + "        v_fragmentColor.a * texture2D(CC_Texture0, v_texCoord).a   \n" + "    ); \n" + "}";
cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT = "attribute vec4 a_position; \n" + "attribute vec2 a_texCoord; \n" + "attribute vec4 a_color;  \n" + "varying lowp vec4 v_fragmentColor; \n" + "varying mediump vec2 v_texCoord; \n" + "void main() \n" + "{ \n" + "    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n" + "    v_fragmentColor = a_color; \n" + "    v_texCoord = a_texCoord; \n" + "}";
cc.SHADER_POSITION_TEXTURE_COLOR_FRAG = "precision lowp float;\n" + "varying vec4 v_fragmentColor; \n" + "varying vec2 v_texCoord; \n" + "void main() \n" + "{ \n" + "    gl_FragColor = v_fragmentColor * texture2D(CC_Texture0, v_texCoord); \n" + "}";
cc.SHADER_POSITION_TEXTURE_COLOR_VERT = "attribute vec4 a_position; \n" + "attribute vec2 a_texCoord; \n" + "attribute vec4 a_color;  \n" + "varying lowp vec4 v_fragmentColor; \n" + "varying mediump vec2 v_texCoord; \n" + "void main() \n" + "{ \n" + "    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n" + "    v_fragmentColor = a_color; \n" + "    v_texCoord = a_texCoord; \n" + "}";
cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG = "precision lowp float;   \n" + "varying vec4 v_fragmentColor; \n" + "varying vec2 v_texCoord;   \n" + "uniform float CC_alpha_value; \n" + "void main() \n" + "{  \n" + "    vec4 texColor = texture2D(CC_Texture0, v_texCoord);  \n" + "    if ( texColor.a <= CC_alpha_value )          \n" + "        discard; \n" + "    gl_FragColor = texColor * v_fragmentColor;  \n" + "}";
cc.SHADEREX_SWITCHMASK_FRAG = "precision lowp float; \n" + "varying vec4 v_fragmentColor; \n" + "varying vec2 v_texCoord; \n" + "uniform sampler2D u_texture;  \n" + "uniform sampler2D   u_mask;   \n" + "void main()  \n" + "{  \n" + "    vec4 texColor   = texture2D(u_texture, v_texCoord);  \n" + "    vec4 maskColor  = texture2D(u_mask, v_texCoord); \n" + "    vec4 finalColor = vec4(texColor.r, texColor.g, texColor.b, maskColor.a * texColor.a);        \n" + "    gl_FragColor    = v_fragmentColor * finalColor; \n" + "}";